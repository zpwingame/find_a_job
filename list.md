以下是"LeetCode 必刷100题"的常见题目列表，涵盖了不同的算法和数据结构：

1. **两数之和** (Two-Sum)
2. **无重复字符的最长子串** (Longest-Substring-Without-Repeating-Characters)
3. **寻找两个正序数组的中位数** (Median-of-Two-Sorted-Arrays)
4. **最长回文子串** (Longest-Palindromic-Substring)
5. **反转整数** (Reverse-Integer)
6. **字符串转换整数 (atoi)** (String-to-Integer-(atoi))
7. **删除排序数组中的重复项** (Remove-Duplicates-from-Sorted-Array)
8. **删除链表的倒数第N个节点** (Remove-Nth-Node-From-End-of-List)
9. **有效的括号** (Valid-Parentheses)
10. **合并两个有序链表** (Merge-Two-Sorted-Lists)
11. **生成括号** (Generate-Parentheses)
12. **括号生成** (Generate-Parentheses)
13. **罗马数字转整数** (Roman-to-Integer)
14. **最长公共前缀** (Longest-Common-Prefix)
15. **三数之和** (3Sum)
16. **最接近的三数之和** (3Sum-Closest)
17. **有效的数独** (Valid-Sudoku)
18. **旋转图像** (Rotate-Image)
19. **删除链表的节点** (Delete-Node-in-a-Linked-List)
20. **合并K个升序链表** (Merge-k-Sorted-Lists)
21. **二叉树的最大深度** (Maximum-Depth-of-Binary-Tree)
22. **二叉树的最小深度** (Minimum-Depth-of-Binary-Tree)
23. **对称二叉树** (Symmetric-Tree)
24. **路径总和** (Path-Sum)
25. **二叉树的层序遍历** (Binary-Tree-Level-Order-Traversal)
26. **二叉搜索树的最近公共祖先** (Lowest-Common-Ancestor-of-a-Binary-Search-Tree)
27. **岛屿的个数** (Number-of-Islands)
28. **爬楼梯** (Climbing-Stairs)
29. **买卖股票的最佳时机** (Best-Time-to-Buy-and-Sell-Stock)
30. **最小路径和** (Minimum-Path-Sum)
31. **零钱兑换** (Coin-Change)
32. **最长有效括号** (Longest-Valid-Parentheses)
33. **动态规划：打家劫舍** (House-Robber)
34. **动态规划：打家劫舍 II** (House-Robber-II)
35. **单词搜索** (Word-Search)
36. **单词拆分** (Word-Break)
37. **全排列** (Permutations)
38. **全排列 II** (Permutations-II)
39. **组合总和** (Combination-Sum)
40. **组合总和 II** (Combination-Sum-II)
41. **子集** (Subsets)
42. **子集 II** (Subsets-II)
43. **N皇后** (N-Queens)
44. **N皇后 II** (N-Queens-II)
45. **图的最短路径** (Shortest-Path-in-a-Grid)
46. **最小覆盖子串** (Minimum-Window-Substring)
47. **字符串的排列** (Permutation-in-String)
48. **K个一组翻转链表** (Reverse-Nodes-in-k-Group)
49. **二叉树的直径** (Diameter-of-Binary-Tree)
50. **最小栈** (Min-Stack)
51. **LRU缓存机制** (LRU-Cache)
52. **设计循环队列** (Design-Circular-Queue)
53. **设计链表** (Design-Linked-List)

请注意，这个列表可能会有所不同，具体取决于个人的学习目标和需求。



以下是"LeetCode 必刷100题"的推荐列表，涵盖了常见的数据结构和算法：

1. **两数之和** (Two-Sum)
2. **两数相加** (Add-Two-Numbers)
3. **无重复字符的最长子串** (Longest-Substring-Without-Repeating-Characters)
4. **寻找两个正序数组的中位数** (Median-of-Two-Sorted-Arrays)
5. **最长回文子串** (Longest-Palindromic-Substring)
6. **合并两个有序链表** (Merge-Two-Sorted-Lists)
7. **删除排序链表中的重复元素** (Remove-Duplicates-from-Sorted-List)
8. **括号生成** (Generate-Parentheses)
9. **有效的括号** (Valid-Parentheses)
10. **合并区间** (Merge-Intervals)
11. **旋转数组** (Rotate-Array)
12. **反转链表** (Reverse-Linked-List)
13. **二叉树的最大深度** (Maximum-Depth-of-Binary-Tree)
14. **二叉树的最小深度** (Minimum-Depth-of-Binary-Tree)
15. **对称二叉树** (Symmetric-Tree)
16. **路径总和** (Path-Sum)
17. **二叉树的层序遍历** (Binary-Tree-Level-Order-Traversal)
18. **二叉搜索树的最近公共祖先** (Lowest-Common-Ancestor-of-a-Binary-Search-Tree)
19. **岛屿的个数** (Number-of-Islands)
20. **爬楼梯** (Climbing-Stairs)
21. **买卖股票的最佳时机** (Best-Time-to-Buy-and-Sell-Stock)
22. **最大子序和** (Maximum-Subarray)
23. **最小路径和** (Minimum-Path-Sum)
24. **零钱兑换** (Coin-Change)
25. **全排列** (Permutations)
26. **组合总和** (Combination-Sum)
27. **三数之和** (3Sum)
28. **四数之和** (4Sum)
29. **字符串相乘** (Multiply-Strings)
30. **最长公共前缀** (Longest-Common-Prefix)
31. **搜索旋转排序数组** (Search-in-Rotated-Sorted-Array)
32. **单词搜索** (Word-Search)
33. **最小窗口子串** (Minimum-Window-Substring)
34. **K 个一组翻转链表** (Reverse-Nodes-in-k-Group)
35. **N 皇后** (N-Queens)
36. **有效的数独** (Valid-Sudoku)
37. **数独解法** (Sudoku-Solver)
38. **字母异位词分组** (Group-Anagrams)
39. **最小覆盖子串** (Minimum-Window-Substring)
40. **字符串的排列** (Permutation-in-String)
41. **最长有效括号** (Longest-Valid-Parentheses)
42. **盛最多水的容器** (Container-With-Most-Water)
43. **最小栈** (Min-Stack)
44. **LRU缓存机制** (LRU-Cache)
45. **设计循环队列** (Design-Circular-Queue)
46. **设计链表** (Design-Linked-List)
47. **设计哈希映射** (Design-HashMap)
48. **设计哈希集合** (Design-HashSet)
49. **单词拆分** (Word-Break)
50. **单词拆分 II** (Word-Break-II)
51. **最小路径和** (Minimum-Path-Sum)
52. **合并K个升序链表** (Merge-k-Sorted-Lists)
53. **寻找峰值** (Find-Peak-Element)
54. **单调栈** (Monotonic-Stack)
55. **最小路径和** (Minimum-Path-Sum)
56. **二叉树的直径** (Diameter-of-Binary-Tree)
57. **二叉树的最大路径和** (Binary-Tree-Maximum-Path-Sum)
58. **分发糖果** (Candy)
59. **最小覆盖子串** (Minimum-Window-Substring)
60. **全排列 II** (Permutations-II)
61. **组合** (Combinations)
62. **组合总和 III** (Combination-Sum-III)
63. **组合总和 IV** (Combination-Sum-IV)
64. **单词搜索 II** (Word-Search-II)
65. **最小路径和** (Minimum-Path-Sum)
66. **最小覆盖子串** (Minimum-Window-Substring)
67. **字符串的排列** (Permutation-in-String)
68. **最长有效括号** (Longest-Valid-Parentheses)
69. **盛最多水的容器** (Container-With-Most-Water)
70. **最小栈** (Min-Stack)
71. **LRU缓存机制** (LRU-Cache)
72. **设计循环队列** (Design-Circular-Queue)
73. **设计链表** (Design-Linked-List)
74. **设计哈希映射** (Design-HashMap)
75. **设计哈希集合** (Design-HashSet)
76. **单词拆分** (Word-Break)
77. **单词拆分 II** (Word-Break-II)
78. **最小路径和** (Minimum-Path-Sum)
79. **合并K个升序链表** (Merge-k-Sorted-Lists)
80. **寻找峰值** (Find-Peak-Element)
81. **单调栈** (Monotonic-Stack)
82. **二叉树的直径** (Diameter-of-Binary-Tree)
83. **二叉树的最大路径和** (Binary-Tree-Maximum-Path-Sum)
84. **分发糖果** (Candy)
85. **最小覆盖子串** (Minimum-Window-Substring)
86. **全排列 II** (Permutations-II)
87. **组合** (Combinations)
88. **组合总和 III** (Combination-Sum-III)
89. **组合总和 IV** (Combination-Sum-IV)
90. **单词搜索 II** (Word-Search-II)

希望这个列表对您有所帮助！如果您需要某个特定题目的解法或详细信息，请告诉我。


《剑指 Offer》是一本涵盖了多种编程面试题的书籍，以下是一些常见的题目：

1. **数组和字符串**
   - 数组中重复的数字
   - 替换空格
   - 旋转数组
   - 最小的K个数

2. **链表**
   - 从尾到头打印链表
   - 合并两个排序的链表
   - 反转链表
   - 找到链表的中间节点

3. **树**
   - 二叉树的深度
   - 二叉树的镜像
   - 二叉搜索树的第K个节点
   - 重建二叉树

4. **动态规划**
   - 矩阵中的路径
   - 最小路径和
   - 斐波那契数列
   - 股票的最大利润

5. **回溯算法**
   - 组合总和
   - 全排列
   - N皇后问题
   - 子集问题

6. **其他**
   - 最小栈
   - 旋转数组的最小数字
   - 硬币问题
   - 字符串的排列

这些题目涵盖了数据结构和算法的多个方面，适合准备编程面试的候选人。





当然可以，以下是一些常见算法类型的 LeetCode 题目示例：

### 1. 二分查找 (Binary Search)
```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let left = 0, right = nums.length - 1;
    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (nums[mid] === target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;
};

// Test cases
console.log(search([-1,0,3,5,9,12], 9)); // Expected output: 4
console.log(search([-1,0,3,5,9,12], 2)); // Expected output: -1
```

### 2. 动态规划 (Dynamic Programming)
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {  // 最长递增子序列
    if (nums.length === 0) return 0;
    const dp = Array(nums.length).fill(1);
    for (let i = 1; i < nums.length; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
    return Math.max(...dp);
};

// Test cases
console.log(lengthOfLIS([10,9,2,5,3,7,101,18])); // Expected output: 4
console.log(lengthOfLIS([0,1,0,3,2,3])); // Expected output: 4
```

### 3. 回溯 (Backtracking)
```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
    const result = [];
    const backtrack = (path, used) => {
        if (path.length === nums.length) {
            result.push([...path]);
            return;
        }
        for (let i = 0; i < nums.length; i++) {
            if (used[i]) continue;
            path.push(nums[i]);
            used[i] = true;
            backtrack(path, used);
            path.pop();
            used[i] = false;
        }
    };
    backtrack([], Array(nums.length).fill(false));
    return result;
};

// Test cases
console.log(permute([1,2,3])); // Expected output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

### 4. 贪心算法 (Greedy)
```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    let maxSum = nums[0];
    let currentSum = nums[0];
    for (let i = 1; i < nums.length; i++) {
        currentSum = Math.max(nums[i], currentSum + nums[i]);
        maxSum = Math.max(maxSum, currentSum);
    }
    return maxSum;
};

// Test cases
console.log(maxSubArray([-2,1,-3,4,-1,2,1,-5,4])); // Expected output: 6
console.log(maxSubArray([1])); // Expected output: 1
```

### 5. 图算法 (Graph Algorithms)
```javascript
/**
 * @param {number} n
 * @param {number[][]} edges
 * @return {boolean}
 */
var validTree = function(n, edges) {
    if (n === 0) return true;
    const adjList = Array.from({ length: n }, () => []);
    for (const [u, v] of edges) {
        adjList[u].push(v);
        adjList[v].push(u);
    }
    const visited = new Set();
    const dfs = (node, parent) => {
        if (visited.has(node)) return false;
        visited.add(node);
        for (const neighbor of adjList[node]) {
            if (neighbor === parent) continue;
            if (!dfs(neighbor, node)) return false;
        }
        return true;
    };
    return dfs(0, -1) && visited.size === n;
};

// Test cases
console.log(validTree(5, [[0,1],[0,2],[0,3],[1,4]])); // Expected output: true
console.log(validTree(5, [[0,1],[1,2],[2,3],[1,3],[1,4]])); // Expected output: false
```

这些题目涵盖了常见的算法类型，希望对你有帮助！